#!/bin/bash

# clear-dev-clutter: Clean development artifacts
# Usage: clear-dev-clutter [options]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
DRY_RUN=false
FORCE=false
VERBOSE=false

# Common development artifacts to clean
CLEANUP_PATTERNS=(
    # Python
    "__pycache__"
    "*.pyc"
    "*.pyo"
    "*.pyd"
    ".pytest_cache"
    ".coverage"
    "htmlcov"
    ".mypy_cache"
    ".ruff_cache"
    ".hypothesis"
    "*.egg-info"
    "dist"
    "build"
    ".tox"
    ".venv"
    "venv"
    "env"
    ".env"
    
    # Node.js
    "node_modules"
    "npm-debug.log"
    "yarn-debug.log"
    "yarn-error.log"
    ".npm"
    ".yarn"
    ".pnpm-store"
    "dist"
    "build"
    ".next"
    ".nuxt"
    ".output"
    ".cache"
    
    # Java
    "target"
    ".gradle"
    "build"
    "out"
    ".idea"
    "*.iml"
    ".classpath"
    ".project"
    ".settings"
    
    # Go
    "bin"
    "pkg"
    "*.exe"
    "*.test"
    "*.out"
    
    # Rust
    "target"
    "Cargo.lock"
    
    # Ruby
    "*.gem"
    ".bundle"
    "vendor"
    "tmp"
    
    # PHP
    "vendor"
    "composer.lock"
    
    # General
    ".DS_Store"
    "Thumbs.db"
    "*.log"
    "*.swp"
    "*.swo"
    "*~"
    ".vscode"
    ".idea"
    ".vs"
    "*.sublime-*"
    ".project"
    ".classpath"
    ".settings"
    "*.bak"
    "*.tmp"
    "*.temp"
    "*.orig"
    "*.rej"
    "*.patch"
    "*.diff"
    "*.pid"
    "*.seed"
    "*.pid.lock"
)

# Help message
show_help() {
    cat << EOF
Usage: clear-dev-clutter [options]

Clean development artifacts and temporary files.

Options:
    -d, --dry-run     Show what would be deleted without actually deleting
    -f, --force       Force deletion without confirmation
    -v, --verbose     Show detailed output
    -h, --help        Show this help message

Examples:
    clear-dev-clutter              # Interactive mode
    clear-dev-clutter --dry-run    # Show what would be deleted
    clear-dev-clutter --force      # Force deletion without confirmation
    clear-dev-clutter --verbose    # Show detailed output
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Function to get total size of files
get_total_size() {
    local size=0
    while IFS= read -r file; do
        if [ -f "$file" ]; then
            size=$((size + $(stat -f %z "$file" 2>/dev/null || stat -c %s "$file" 2>/dev/null)))
        fi
    done
    echo "$size"
}

# Function to format size
format_size() {
    local size=$1
    local units=("B" "KB" "MB" "GB" "TB")
    local unit=0
    
    while [ $size -ge 1024 ] && [ $unit -lt ${#units[@]} ]; do
        size=$((size / 1024))
        unit=$((unit + 1))
    done
    
    echo "${size}${units[$unit]}"
}

# Find files to clean
echo -e "${BLUE}Scanning for development artifacts...${NC}"

# Build find command
FIND_CMD="find . -type f -o -type d"
for pattern in "${CLEANUP_PATTERNS[@]}"; do
    FIND_CMD="$FIND_CMD -o -name '$pattern'"
done

# Get list of files
mapfile -t files < <(eval "$FIND_CMD" 2>/dev/null)

# Handle no files found
if [ ${#files[@]} -eq 0 ]; then
    echo -e "${GREEN}No development artifacts found${NC}"
    exit 0
fi

# Calculate total size
total_size=$(printf '%s\n' "${files[@]}" | get_total_size)
formatted_size=$(format_size "$total_size")

# Show files to be deleted
echo -e "\n${YELLOW}Found ${#files[@]} files/directories to clean (${formatted_size}):${NC}"
if [ "$VERBOSE" = true ]; then
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            size=$(stat -f %z "$file" 2>/dev/null || stat -c %s "$file" 2>/dev/null)
            echo -e "${RED}$file${NC} ($(format_size "$size"))"
        else
            echo -e "${RED}$file${NC} (directory)"
        fi
    done
else
    # Group files by type
    declare -A file_types
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            ext="${file##*.}"
            if [ "$ext" = "$file" ]; then
                ext="no extension"
            fi
            file_types["$ext"]=$((file_types["$ext"] + 1))
        else
            file_types["directory"]=$((file_types["directory"] + 1))
        fi
    done
    
    # Show summary
    for type in "${!file_types[@]}"; do
        echo -e "${RED}${file_types[$type]}${NC} $type files"
    done
fi

# Handle dry run
if [ "$DRY_RUN" = true ]; then
    echo -e "${BLUE}Dry run - no files were deleted${NC}"
    exit 0
fi

# Handle force delete
if [ "$FORCE" = true ]; then
    echo -e "${YELLOW}Force deleting files...${NC}"
    for file in "${files[@]}"; do
        if [ "$VERBOSE" = true ]; then
            echo -e "Deleting: ${RED}$file${NC}"
        fi
        rm -rf "$file" 2>/dev/null || true
    done
    echo -e "${GREEN}Cleanup complete${NC}"
    exit 0
fi

# Interactive mode
echo -e "\n${YELLOW}Do you want to delete these files? [y/N]${NC}"
read -r response
if [[ "$response" =~ ^[Yy]$ ]]; then
    for file in "${files[@]}"; do
        if [ "$VERBOSE" = true ]; then
            echo -e "Deleting: ${RED}$file${NC}"
        fi
        rm -rf "$file" 2>/dev/null || true
    done
    echo -e "${GREEN}Cleanup complete${NC}"
else
    echo -e "${BLUE}Operation cancelled${NC}"
fi